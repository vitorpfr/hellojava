// This file was initially auto-generated by IntelliJ - see BankingMain file to see how
// To change test configs: right click, inside, then "Modify run configuration"
// Good practice right after file creation: add fail() to all test methods, before implementing them
package banking;

import org.junit.jupiter.api.*;

import static org.junit.jupiter.api.Assertions.*;

class BankAccountTest {
    private BankAccount account;
    private static int count;

    @BeforeAll // runs once before all tests (requires the method to be static)
    static void beforeClass() {
        System.out.println("This executes before any test cases, once. Count = " + count++);
    }

    @BeforeEach // runs every time before each test
    void setup() {
        account = new BankAccount("Tim", "Buchalka", 1000.00, BankAccount.CHECKING);
        System.out.println("Setup done, running a test...");
    }

    // @Test annotation is used by JUnit to identify that this method should be run when tests are ran
    // before annotations existed, the method need to be called depositTest for ex., and it was identified by name
    @Test
    void deposit() {
        double balance = account.deposit(200.00, true);
        assertEquals(1200.00, balance, 0); // delta parameters allows some leeway in the numerical comparison
    }

    @Test
    void withdraw_branch() {
        double balance = account.withdraw(600.00, true);
        assertEquals(400.00, balance, 0);
    }

    // if we want to assert a test throws an exception, we can use assertThrows(exceptionClass, executable/lambda)
    // assertThrows only works on JUnit5. For older versions:
        // Junit3: execute command in try/catch block, catching the expected exception and not doing anything (and adding fail to try block)
        // Junit4: add (expected = IllegalArgumentException.class) to the annotation, then execute command inside brackets
    @Test()
    void withdraw_notBranch() {
        assertThrows(IllegalArgumentException.class, () -> account.withdraw(600.00, false));
    }

    // good practice: each test has one assertion
    // if there's the need to test getBalance in deposit and withdraw scenario, add two tests
    @Test
    void getBalance_deposit() {
        account.deposit(200.00, true);
        assertEquals(1200.00, account.getBalance(), 0);
    }

    @Test
    void getBalance_withdraw() {
        account.withdraw(200.00, true);
        assertEquals(800.00, account.getBalance(), 0);
    }

    @Test
    void isChecking_true() {
//        assertEquals(true, account.isChecking()); // bad practice
        assertTrue(account.isChecking()); // best practice
        assertTrue(account.isChecking(), "The account is NOT a checking account"); // best practice with provided error message when it fails
    }

    @AfterAll
    static void afterClass() {
        System.out.println("This executes after all test cases, once. Count = " + count++);
    }

    @AfterEach
    void teardown() {
        System.out.println("Count = " + count++);
    }

    // other relevant assert methods (most are intuitive):
    // assertNotEquals()
    // assertArrayEquals()
    // assertNull() and assertNotNull()
    // assertSame() and assertNotSame() - checks if two instances are the exact same object instance (or not)
        // assertEquals uses the .equals() methods, while assertSame compares the object references
    // assertThat() - compares value against a JUnit matcher; with it we can compare a value against a range of values











    // dummy test, example
//    @Test
//    void dummyTest() {
//        fail("This test has yet to be implemented"); // this line is used to fail a test purposefully
//        // first arg is expected value, second arg is actual value
////        assertEquals(20, 21); // this test fails
//        assertEquals(21, 21); // this test succeeds
//    }
}